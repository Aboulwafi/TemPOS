using System;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

namespace TemposLibrary
{
    public class SRP6
    {
        #region Licensed Access Only
        static SRP6()
        {
#if !DEBUG
            if (!System.Linq.Enumerable.SequenceEqual(
                typeof(SRP6).Assembly.GetName().GetPublicKeyToken(),
                System.Reflection.Assembly.GetEntryAssembly().GetName().GetPublicKeyToken()))
            {
                throw new Exception("You are not licensed to use TemposLibrary.dll");
            }
#endif
        }
        #endregion

#if !DEMO
        // Constructor initialized variables
        private BigInteger modulus_N, salt, generator_g, multiplier_k;

        // Server calculated variables
        private BigInteger saltedIdentityHash, verifier, scrambler;

        // Common variables
        private BigInteger sessionKey, privateKey, publicKey;

        public BigInteger Modulus
        {
            get { return modulus_N; }
            private set { modulus_N = value; }
        }

        public BigInteger Salt
        {
            get { return salt; }
            private set { salt = value; }
        }

        public BigInteger Generator
        {
            get { return generator_g; }
            private set { generator_g = value; }
        }

        public byte[] IdentityHash
        {
            get;
            private set;
        }

        public BigInteger SaltedIdentityHash
        {
            get { return saltedIdentityHash; }
            private set { saltedIdentityHash = value; }
        }

        public BigInteger Multiplier
        {
            get { return multiplier_k; }
            private set { multiplier_k = value; }
        }

        public BigInteger Scrambler
        {
            get { return scrambler; }
            private set { scrambler = value; }
        }

        public BigInteger Verifier
        {
            get { return verifier; }
            private set { verifier = value; }
        }

        public BigInteger SessionKey
        {
            get { return sessionKey; }
            private set { sessionKey = value; }
        }

        public BigInteger PrivateKey
        {
            get { return privateKey; }
            private set { privateKey = value; }
        }

        public BigInteger PublicKey
        {
            get { return publicKey; }
            private set { publicKey = value; }
        }

        /// <summary>
        /// The initial vector used for the AES Decrypt/Encrypt methods
        /// </summary>
        public string InitialVector
        {
            get;
            set;
        }

        // Server Constructor, Radix 16 strings, 256-bit predef values
        public SRP6(byte[] identity, String modulus_N, int generator_g, int saltBits,
            int scramblerBits, string initialVector = "OFRna73m*aze01xY")
        {
            InitialVector = initialVector;

            Modulus = BigIntegerExtension.Create(modulus_N, 16);
            Generator = BigIntegerExtension.Create("" + generator_g, 10);
            Multiplier = BigIntegerExtension.Create("3", 10);
            Salt = BigIntegerExtension.Create(saltBits, new Random());
            Scrambler = BigIntegerExtension.Create(scramblerBits, new Random());

            // Server-side variables
            IdentityHash = identity;
            SaltedIdentityHash = bytesToBig(Sha1Hash(salt.ToByteArray(), identity));

            Verifier = this.generator_g.modPow(saltedIdentityHash, this.modulus_N);

            // Random 128 bit number that is a probable prime
            PrivateKey = BigIntegerExtension.GeneratePseudoPrime(128, 100, new Random());

            // kv + g^b   (mod N)
            PublicKey = this.multiplier_k.multiply(verifier).add(this.generator_g.modPow(privateKey, this.modulus_N));

        }

        // Client Constructor, username not needed, salt not generated by client
        public SRP6(byte[] identityHash, String modulus_N, int generator_g,
            String salt, string initialVector = "OFRna73m*aze01xY")
        {
            InitialVector = initialVector;

            Modulus = BigIntegerExtension.Create(modulus_N, 16);
            Generator = BigIntegerExtension.Create("" + generator_g, 10);
            Multiplier = BigIntegerExtension.Create("3", 10);
            Salt = BigIntegerExtension.Create(salt, 16);

            // Client-side variables
            PrivateKey = BigIntegerExtension.GeneratePseudoPrime(128, 100, new Random());

            // g^a   (mod N)
            PublicKey = this.generator_g.modPow(privateKey, this.modulus_N);

            // Server-side variables
            SaltedIdentityHash = bytesToBig(Sha1Hash(Salt.ToByteArray(), identityHash));
        }

        public void SetSessionKey(String pubKeyString, String scrambler = null)
        {
            BigInteger pubKey = BigIntegerExtension.Create(pubKeyString, 16);
            if (scrambler == null) // Server SessionKey
            {
                // (Av^u) ^ b   (mod N)
                SessionKey = pubKey.multiply(verifier.modPow(Scrambler, Modulus)).modPow(PrivateKey, Modulus);
            }
            else // Client SessionKey
            {
                Scrambler = BigIntegerExtension.Create(scrambler, 16);
                BigInteger temp = PrivateKey.add(Scrambler.multiply(SaltedIdentityHash));
                SessionKey = pubKey.subtract((Generator.modPow(SaltedIdentityHash, Modulus)).multiply(Multiplier)).modPow(temp, Modulus);
            }
        }

        public String GetSessionKey()
        {
            return BytesToHex(SessionKey.ToUnsignedByteArray());
        }

        public String GetMultiplier()
        {
            return BytesToHex(Multiplier.ToUnsignedByteArray());
        }

        public String GetScrambler()
        {
            return BytesToHex(Scrambler.ToUnsignedByteArray());
        }

        public String GetGenerator()
        {
            return BytesToHex(Generator.ToUnsignedByteArray());
        }

        public String GetPrivateKey()
        {
            return BytesToHex(PrivateKey.ToUnsignedByteArray());
        }

        public String GetPublicKey()
        {
            return BytesToHex(PublicKey.ToUnsignedByteArray());
        }

        public String GetModulus()
        {
            return BytesToHex(Modulus.ToUnsignedByteArray());
        }

        public String GetIdentityHash()
        {
            return BytesToHex(SaltedIdentityHash.ToUnsignedByteArray());
        }

        public String GetSalt()
        {
            return BytesToHex(Salt.ToUnsignedByteArray());
        }

        public String GetVerifier()
        {
            return BytesToHex(Verifier.ToUnsignedByteArray());
        }

        public static byte[] GenerateIdentityHash(String user, String password)
        {
            return Sha1Hash(Encoding.Unicode.GetBytes((user + ":" + password)));
        }
#endif
        public static byte[] Sha1Hash(byte[] input1, byte[] input2 = null,
            byte[] input3 = null, byte[] input4 = null)
        {
            try
            {
                SHA1 sha = new SHA1CryptoServiceProvider();
                sha.ComputeHash(ConcatArray(input1, input2, input3, input4));
                return sha.Hash;
            }
            catch (System.Exception e)
            {
                Console.WriteLine(e.Message);
                return null;
            }
        }

        public static byte[] ConcatArray(byte[] first, byte[] second, byte[] third = null,
            byte[] forth = null, byte[] fifth = null)
        {
            if (first == null)
                throw new ArgumentNullException();
            if (second == null)
                return first;
            int length = first.Length + second.Length +
                (third != null ? third.Length : 0) +
                (forth != null ? forth.Length : 0) +
                (fifth != null ? fifth.Length : 0);
            byte[] result = new byte[length];

            // Copy first
            for (int i = 0; i < first.Length; i++)
            {
                result[i] = first[i];
            }
            // Copy second
            for (int i = 0; i < second.Length; i++)
            {
                result[i + first.Length] = second[i];
            }
            // Copy Third
            if (third != null)
            {
                for (int i = 0; i < third.Length; i++)
                {
                    result[i + first.Length + second.Length] = third[i];
                }
                if (forth != null)
                {
                    for (int i = 0; i < forth.Length; i++)
                    {
                        result[i + first.Length + second.Length + third.Length] = forth[i];
                    }
                    if (fifth != null)
                    {
                        for (int i = 0; i < fifth.Length; i++)
                        {
                            result[i + first.Length + second.Length + third.Length + forth.Length] =
                                fifth[i];
                        }
                    }
                }
            }
            // Return result
            return result;
        }

#if !DEMO
        public static string BytesToHex(byte[] data)
        {
            if (data == null)
                return "";
            string result = "";
            for (int i = data.Length - 1; i >= 0; i--)
                result += data[i].ToString("X2");
            return result;
        }

        private static BigInteger bytesToBig(byte[] bytes)
        {
            return BigIntegerExtension.Create(BytesToHex(bytes), 16);
        }

        /// <summary>
        /// Encrypts a string
        /// </summary>
        /// <param name="PlainText">Text to be encrypted</param>
        /// <returns>The encrypted string</returns>
        public string Encrypt(string PlainText)
        {
            if (string.IsNullOrEmpty(PlainText))
                return "";
            byte[] PlainTextBytes = Encoding.UTF8.GetBytes(PlainText);
            byte[] CipherTextBytes = Encrypt(PlainTextBytes);
            return Convert.ToBase64String(CipherTextBytes);
        }

        public Stream Encrypt(Stream stream)
        {
            byte[] results = new byte[stream.Length];
            stream.Read(results, 0, results.Length);
            byte[] encryptedBytes = Encrypt(results);
            return new MemoryStream(encryptedBytes, false);
        }

        public byte[] Encrypt(byte[] PlainTextBytes)
        {
            string Password = GetSessionKey();
            string Salt = GetSalt();
            string HashAlgorithm = "SHA1";
            int PasswordIterations = 2;
            int KeySize = 256;
            if (PlainTextBytes == null)
                return null;
            byte[] InitialVectorBytes = Encoding.ASCII.GetBytes(InitialVector);
            byte[] SaltValueBytes = Encoding.ASCII.GetBytes(Salt);
            PasswordDeriveBytes DerivedPassword = new PasswordDeriveBytes(Password, SaltValueBytes, HashAlgorithm, PasswordIterations);
            byte[] KeyBytes = DerivedPassword.GetBytes(KeySize / 8);
            RijndaelManaged SymmetricKey = new RijndaelManaged();
            SymmetricKey.Mode = CipherMode.CBC;
            byte[] CipherTextBytes = null;
            using (ICryptoTransform Encryptor = SymmetricKey.CreateEncryptor(KeyBytes, InitialVectorBytes))
            {
                using (MemoryStream MemStream = new MemoryStream())
                {
                    using (CryptoStream CryptoStream = new CryptoStream(MemStream, Encryptor, CryptoStreamMode.Write))
                    {
                        CryptoStream.Write(PlainTextBytes, 0, PlainTextBytes.Length);
                        CryptoStream.FlushFinalBlock();
                        CipherTextBytes = MemStream.ToArray();
                        MemStream.Close();
                        CryptoStream.Close();
                    }
                }
            }
            SymmetricKey.Clear();
            return CipherTextBytes;
        }

        /// <summary>
        /// Decrypts a string
        /// </summary>
        /// <param name="CipherText">Text to be decrypted</param>
        /// <returns>The decrypted string</returns>
        public string Decrypt(string CipherText)
        {
            if (string.IsNullOrEmpty(CipherText))
                return "";
            int ByteCount;
            byte[] PlainTextBytes = Decrypt(Convert.FromBase64String(CipherText), out ByteCount);
            return Encoding.UTF8.GetString(PlainTextBytes, 0, ByteCount);
        }

        public byte[] Decrypt(byte[] CipherTextBytes)
        {
            if (CipherTextBytes == null)
                return null;
            int ByteCount;
            byte[] decryptedArray = Decrypt(CipherTextBytes, out ByteCount);
            return SubArray(decryptedArray, 0, ByteCount);
        }

        private byte[] Decrypt(byte[] CipherTextBytes, out int ByteCount)
        {
            string Password = GetSessionKey();
            string Salt = GetSalt();
            string HashAlgorithm = "SHA1";
            int PasswordIterations = 2;
            int KeySize = 256;
            if (CipherTextBytes == null)
            {
                ByteCount = 0;
                return null;
            }
            byte[] InitialVectorBytes = Encoding.ASCII.GetBytes(InitialVector);
            byte[] SaltValueBytes = Encoding.ASCII.GetBytes(Salt);
            PasswordDeriveBytes DerivedPassword = new PasswordDeriveBytes(Password, SaltValueBytes, HashAlgorithm, PasswordIterations);
            byte[] KeyBytes = DerivedPassword.GetBytes(KeySize / 8);
            RijndaelManaged SymmetricKey = new RijndaelManaged();
            SymmetricKey.Mode = CipherMode.CBC;
            byte[] PlainTextBytes = new byte[CipherTextBytes.Length];
            ByteCount = 0;
            using (ICryptoTransform Decryptor = SymmetricKey.CreateDecryptor(KeyBytes, InitialVectorBytes))
            {
                using (MemoryStream MemStream = new MemoryStream(CipherTextBytes))
                {
                    using (CryptoStream CryptoStream = new CryptoStream(MemStream, Decryptor, CryptoStreamMode.Read))
                    {

                        ByteCount = CryptoStream.Read(PlainTextBytes, 0, PlainTextBytes.Length);
                        MemStream.Close();
                        CryptoStream.Close();
                    }
                }
            }
            SymmetricKey.Clear();
            //return Encoding.UTF8.GetString(PlainTextBytes, 0, ByteCount);
            return PlainTextBytes;
        }

        public void EncryptAndSend(AsynchronousSocket socket, byte[] plainText)
        {
            // Send an encrypted byte array to the client
            byte[] encrypted = Encrypt(plainText);
            socket.Send(encrypted, 0, encrypted.Length);
        }

        public void EncryptAndSend(AsynchronousSocket socket, string plainText)
        {
            byte[] bytes = ASCIIEncoding.ASCII.GetBytes(plainText);
            EncryptAndSend(socket, bytes);
        }

        public static byte[] SubArray(byte[] totalArray, int offset, int length)
        {
            if (offset + length > totalArray.Length)
                throw new ArgumentException();
            byte[] result = new byte[length];
            for (int i = 0; i < length; i++)
            {
                result[i] = totalArray[i + offset];
            }
            return result;
        }

        public static string ArrayToString(byte[] totalArray, int offset, int length)
        {
            byte[] array = SubArray(totalArray, offset, length);
            return ASCIIEncoding.ASCII.GetString(array);
        }
#endif
    }
}